# =========================
#  PIPELINE: FIREFOX BUILDS (Final Stable Version)
# =========================

input {
  beats {
    port => 5044
  }
}


filter {
  # ==========================================
  # 1. Extraire la date du nom de fichier
  # ==========================================
  grok {
    match => { "log.file.path" => ".*[\\\/](?<file_date>\d{4}-\d{2}-\d{2})" }
    tag_on_failure => []
  }

  # ==========================================
  # 2. GROK des différents types de lignes
  # ==========================================
  grok {
    match => {
      "message" => [
        # --- Step START / FINISH avec timestamp complet ---
        "^========= %{WORD:step_status} %{GREEDYDATA:step_name} \(results: %{INT:results_code:int}, elapsed: %{INT:step_elapsed_secs:int} secs\) \(at %{TIMESTAMP_ISO8601:step_at_ts}\) =========$",

        # --- Résumé de résultats textuel ---
        "^results:\s*%{WORD:results_text}\s*\(%{INT:results_count:int}\)$",

        # --- Lignes métadonnées builder/slave/platform/... ---
        "^(buildername|slave|platform|branch|revision|buildid|elapsedTime):\s*%{GREEDYDATA:meta_value}$",

        # --- Code de sortie du programme ---
        "^program finished with exit code %{INT:exit_code:int}$",

        # --- Informations de téléchargement ---
        "^%{TIME:line_time} \(%{NUMBER:transfer_rate:float} %{WORD:transfer_unit}/s\) - %{QUOTEDSTRING:downloaded_file} saved \[%{INT:bytes_downloaded:int}/%{INT:total_bytes:int}\]$",

        # --- Lignes standard avec loglevel ---
        "^%{TIME:line_time}(?:,%{INT})?\s*%{LOGLEVEL:loglevel}\s*-\s*%{GREEDYDATA:message}$"
      ]
    }
    tag_on_failure => ["_grok_nomatch"]
  }

  # ==========================================
  # 3. Construction du @timestamp
  # ==========================================
  if [step_at_ts] {
    date {
      match => ["step_at_ts", "ISO8601"]
      target => "@timestamp"
    }
  } else if [line_time] and [file_date] {
    mutate {
      add_field => { "combined_ts" => "%{file_date} %{line_time}" }
    }
    date {
      match => ["combined_ts", "YYYY-MM-dd HH:mm:ss", "YYYY-MM-dd HH:mm:ss,SSS"]
      target => "@timestamp"
    }
    mutate { remove_field => ["combined_ts"] }
  }

  # ==========================================
  # 4. Normalisation et conversions
  # ==========================================
  mutate {
    lowercase => ["loglevel", "results_text", "step_status"]
    convert => {
      "results_count"       => "integer"
      "results_code"        => "integer"
      "exit_code"           => "integer"
      "bytes_downloaded"    => "integer"
      "step_elapsed_secs"   => "integer"
    }
  }

  # ==========================================
  # 5. Structuration des métadonnées (buildername, platform, etc.)
  # ==========================================
  if [meta_value] {
    ruby {
      code => '
        key = event.get("message")[/^(\w+):/,1]
        if key
          event.set(key.downcase, event.get("meta_value"))
        end
      '
    }
    mutate { remove_field => ["meta_value"] }
  }

  # ==========================================
  # 6. Tags d’état et enrichissement
  # ==========================================
  if [exit_code] and [exit_code] != 0 {
    mutate { add_tag => ["exit_error"] }
  }
  if [results_text] and [results_text] != "success" {
    mutate { add_tag => ["build_warning_or_failure"] }
  }
  if [http_code] and [http_code] >= 400 {
    mutate { add_tag => ["http_error"] }
  }

  # ==========================================
  # 7. Nettoyage des lignes non reconnues
  # ==========================================
  if "_grok_nomatch" in [tags] {
    drop { }
  }

  # ==========================================
  # 8. Structuration finale pour Elasticsearch
  # ==========================================
  mutate {
    add_field => {
      "event.dataset" => "firefox.build"
      "event.module"  => "firefox"
      "event.category" => "application"
      "event.type" => "log"
    }
  }
}

output {
  elasticsearch {
    hosts => ["http://elasticsearch:9200"]
    index => "firefox-logs-%{+YYYY.MM.dd}"
    ilm_enabled => false
  }
  stdout { codec => rubydebug }
}
